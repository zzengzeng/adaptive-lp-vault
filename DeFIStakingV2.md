# ERC-20 DeFi Staking 协议需求规格说明书 

## 1. 核心代币架构与资金隔离

* **架构定义**：采用 **双币模式**。质押代币 ($Token\_A$) 与奖励代币 ($Token\_B$) 物理隔离，合约地址不同。
* **奖励代币来源机制**：由项目方多签钱包定期转入。
* **隔离机制**：
    * **物理隔离**：合约不具备$Token\_B$的增发权，仅作为托管分发方。
    * **逻辑隔离**：通过全局变量独立核算本金池与奖励储备池。



> **场景分析（精度与本金安全）**：管理员注入奖励时仅更新 `rewardReserves`。即便奖励释放公式因精度产生1wei误差，由于用户本金账本 `userStaked` 是独立定义的，这种误差绝不会导致用户质押的本金被意外锁定或损耗。

---

## 2. 全量合约状态变量清单 (Detailed State Variables)

### 2.1 核心配置与资产 (Immutable & Config)

| 变量名 | 类型 | 含义 | 默认/约束 |
| --- | --- | --- | --- |
| `stakingToken` | `address` | 质押代币 A 地址 (ERC20) | 构造函数指定 |
| `rewardToken` | `address` | 奖励代币 B 地址 (ERC20) | 构造函数指定 |
| `feeRecipient` | `address` | 国库/手续费接收地址 | 部署者指定 |
| `minStakeAmount` | `uint256` | 单笔最小质押量 | 10 * 10^{18} (10 Token) |
| `maxTVLCap` | `uint256` | 协议总锁仓上限 | 初始预设，Admin 可调 |
| `claimCooldown` | `uint256` | 领取/复利操作冷却间隔 | 86400 (24小时) |

### 2.2 收益分发控制 (Global Stats)

| 变量名 | 类型 | 含义 | 更新频率 |
| --- | --- | --- | --- |
| `rewardRate` | `uint256` | 每秒释放奖励量 (wei/sec) | 由 Operator 设置 |
| `periodFinish` | `uint256` | 当前奖励周期的截止时间戳 | 随注入量更新 |
| `lastUpdateTime` | `uint256` | 上次更新奖励点位的时间戳 | 随操作更新 |
| `rewardPerTokenStored` | `uint256` | 全局每单位 A 累计分配到的 B 指数 | 随操作更新 |
| `totalStaked` | `uint256` | 协议内所有用户的总质押本金 | 随 Stake/Withdraw 更新 |

### 2.3 动态配置参数 (Admin Configurable)

| 变量名 | 类型 | 含义 | 限制范围 |
| --- | --- | --- | --- |
| `lockDuration` | `uint256` | 滚动锁定期时长 | 默认 7 天 / **Max: 90 天** |
| `withdrawFeeBP` | `uint256` | 标准提现手续费 (万分位) | 默认 100 (1%) / **Max: 500 (5%)** |
| `penaltyFeeBP` | `uint256` | 强制解押惩罚率 (万分位) | 默认 1000 (10%) / **Max: 2000 (20%)** |

### 2.4 用户账本映射 (User Ledger)

* `userStaked`: 用户当前的质押本金余额。
* `rewards`: 用户已结算待领取的奖励额度。
* `unlockTime`: 用户全额本金的解锁截止时间戳。
* `lastClaimTime`: 用户上次执行 Claim/Compound 时间。

---

## 3. 核心业务操作与约束逻辑

### 3.1 复合质押（Compound）逻辑：奖励转化为本金

复合质押是协议实现 APY（复利收益）的核心路径。它不涉及资产的链上转移，而是合约内部账本的重分类。

#### 3.1.1 操作步骤

1. **收益结算 (Settlement)**：系统触发全局更新钩子，计算用户从上次操作至今的奖励，并计入 `rewards[user]` 映射。
2. **账本划转 (Ledger Transfer)**：
* 获取用户当前的待领奖励余额 。
* 将 `rewards[user]` 账本记录归零。
* 将数值  累加至用户的 `userStaked[user]`（质押本金）中。


3. **全局状态同步**：
* 全局总质押量 `totalStaked` 增加 。
* 合约内部奖励储备 `rewardReserves` 减少 。


4. **操作冷却检查**：必须满足 `block.timestamp >= lastClaimTime[user] + 86400`（即 24 小时内仅允许执行一次）。

#### 3.1.2 锁定期与计时约束

* **执行门槛**：**不受锁定期约束**。即便当前本金处于“锁定中”，用户也可随时执行复利。
* **锁定刷新**：执行后触发 **全额刷新（Rolling Reset）**。
* **逻辑原因**：复利被视为一次“新入金”行为。为防止用户利用复利绕过锁定期提取资产，系统会重置该地址**全额本金**（旧本金 + 复利转入的奖励）的解锁时间。
* **更新公式**：`unlockTime[user] = block.timestamp + lockDuration`。



---

### 3.2 提现管理与锁定期约束逻辑

用户撤回质押本金时，合约将严格根据时间戳校验其是否满足退出条件。

#### 3.2.1 锁定期的定义与配置

* **锁定期长度**：默认 **7 天**（604,800 秒）。
* **配置属性**：**Admin 可调区间**。管理员有权修改时长，但受到代码级硬上限约束（**Max: 90 天**）。
* **计算起点**：从用户**最后一次入金行为**（Stake 或 Compound）的时间点开始计算。

#### 3.2.2 滚动刷新规则（多次质押场景）

协议不采用每笔质押独立计时的复杂逻辑，而是采用统一的“滚动刷新”模式：

* **规则**：用户在锁定期内追加任何数额的质押，其**全额本金**的解锁时间都将从当前操作时刻起重新全额计算。

> **场景分析（多次质押对锁定的影响）**：
> * **周一**：小明质押 500 枚，`unlockTime` 设为下周一。
> * **周五**：小明又质押了 100 枚。
> * **结果**：此时 `unlockTime` 被重置为 **本周五 + 7 天 = 下周五**。小明总共 600 枚代币现在统一在下周五解锁。
> 
> 

---

### 3.3 退出路径场景分析：标准提现 vs 强制解押

根据用户提现时的时间点，协议执行两种截然不同的逻辑路径。

#### 3.3.1 路径 A：已满锁定期 (Standard Withdraw)

* **触发条件**：`block.timestamp >= unlockTime[user]`。
* **手续费**：扣除 **1% 标准提现费**（随持有时间进一步衰减，详见费率衰减表）。
* **奖励处理**：正常结算并全额发放。

#### 3.3.2 路径 B：未满锁定期 (Early Exit / 强制解押)

* **触发条件**：`block.timestamp < unlockTime[user]`。
* **操作流**：用户需调用 `earlyExit()` 函数并确认接受损失。
* **后果一：惩罚性扣款**：扣除提现本金的 **10%** 作为罚金，流向国库。
* **后果二：奖励清零**：用户当前所有已结算未领取的奖励将 **永久没收 (Forfeited)**。

---

### 3.4 业务场景深度分析

* **场景一：复利后的锁定状态变化**
小明质押 1000 枚，锁定期 7 天。在第 6 天（还有 1 天解锁）时产生了收益。他点击 `Compound`，本金变为 1100 枚，但解锁时间从“明天”变为了“7 天后”。这确保了复利产生的新份额也必须履行锁定义务。
* **场景二：强制解押的极端代价**
小明质押 10,000 枚，产生了 500 枚奖励。在第 3 天他选择强制解押。
1. 扣除 10% 罚金 = 1,000 枚本金。
2. 没收并清零 500 枚奖励。
小明最终拿回 9,000 枚本金。这种高昂成本旨在保护协议流动性。


* **场景三：费率衰减后的复利操作**
小明已持有代币 91 天，提现费率已降至 0%。若他此时执行 `Compound`，由于触发了“滚动重置”，他的提现费率将**立即回升到 10%**（进入新的 7 天强制解押期）。

---

## 4. 提现手续费与衰减机制 (Fee Decay)

### 4.1 核心规则

* **计算基数**：基于申请提现的 **本金金额 (Principal)** 计算。
* **费率去向**：实时流向 **国库钱包 (`feeRecipient`)**。

### 4.2 衰减阶梯定义

 $T$的计算起点为用户最后一次入金（Stake 或 Compound）的时间。

| 质押时长 (天) | 费率状态 | 费率 (BP) | 收益结算处理 |
| --- | --- | --- | --- |
| **锁定期** | **强制解押** | **1000 (10%)** | **全部没收销毁** |
| **锁定期7天** | **标准提现** | **100 (1%)** | 正常发放 |
| **7<$T$<90天** | **长期激励** | **50 (0.5%)** | 正常发放 |
| **90天** | **豁免提现** | **0 (0%)** | 正常发放 |

---
## 5. 奖励速率（Reward Rate）

### 5.1 核心定义与单位 (Units)

* **物理单位**：`rewardRate` 的单位是 **wei/second**（即：奖励代币最小单位 / 每秒）。
* **精度控制**：在 Solidity 合约内部计算中，为了防止整数除法产生的精度丢失，所有“每单位代币收益”均会乘以一个 **的放大因子**（Offset）。
* *示例*：如果每秒释放 1 个代币（假设 18 位精度），则 `rewardRate` = 1/sec。



### 5.2 奖励释放模式：持续线性释放 (Continuous Linear Emission)

本协议采用 **流式线性释放模式**（Synthetix 模型），而非按周期（Epoch）结算。

* **释放逻辑**：奖励是随区块链时间戳（Timestamp）的推进，每一秒都在均匀产出。
* **结算触发**：采用“惰性计算”（Lazy Evaluation）。合约不会主动给用户发钱，而是在用户执行任意操作（Stake, Withdraw, Claim, Compound）时，通过 `updateReward` 钩子瞬时计算从“上次更新时间”到“当前时间”之间产生的收益。
* **优势**：极大地节省了 Gas 费，且支持任意数量的用户公平参与。

### 5.3 奖励耗尽保护机制 (Exhaustion Safeguard)

为了防止出现“空头支票”或虚假收益，合约设置了硬性的边界逻辑：

* **截止时间 (`periodFinish`)**：合约记录当前奖励计划的截止时间戳。
* **自动停止逻辑**：在收益指数计算公式中，有效时间被定义为：

* **合约行为**：
    * **自动停止**：一旦当前时间超过 `periodFinish`，上式中的  函数将锁定在 `periodFinish`。
    * **拒绝虚假收益**：即使合约内没有代币了，或者奖励时间已到，公式计算出的增量将变为 **0**。用户看到的“待领奖励”将停留在到期那一刻的数值，**绝不继续累计**。



### 5.4 管理员修改 RewardRate 的处理逻辑

当管理员修改速率或增加奖励总量时，合约遵循 **“结算现状，开启未来”** 的原则，确保用户历史收益不受任何波动影响。

1. **强制即时结算 (Snapshot First)**：
在修改 `rewardRate` 的交易执行瞬间，合约会先自动调用一次全局更新，按**旧速率**将截止到该秒的所有奖励结算到每个用户的 `rewards` 账户中并固化。
2. **速率计算规则**：
    * **如果当前周期未结束**：管理员注入新奖励 。
    * **新速率公式**：
    * 其中  是旧周期内尚未释放的剩余部分。


3. **用户奖励处理**：
    * 用户**已累积但未领取**的奖励被安全地保存在 `rewards[user]` 映射中。
    * **不受影响**：调低速率只会减慢用户*未来*获取奖励的速度，绝对不会减少或清除用户*已赚到*的账面余额。



---

### 5.5 奖励速率场景分析

#### 场景 A：奖励自然耗尽 (Smooth Stop)

* **设定**：管理员注入 604,800 个代币，设置周期为 7 天。`rewardRate` = 1/sec。
* **过程**：在第 7 天结束时，`block.timestamp` 达到了 `periodFinish`。
* **结果**：第 8 天用户登录后，看到自己的待领收益不再增加。用户可以随时 Claim 走之前的奖励。

#### 场景 B：中途调低速率 (Rate Adjustment)

* **设定**：原计划每秒 10 个，小明已质押 1 天，账面有 86.4 万个。管理员发现奖励发太快，将速率降为每秒 1 个。
* **结果**：
1. 管理员提交交易，小明的 86.4 万个奖励在修改前瞬间被“锁死”在账本里，不会减少。
2. 从修改后的那一秒起，小明的收益增加速度变慢。
3. 小明去 Claim 时，拿回的是“旧速率下的 86.4 万 + 新速率下的累计部分”。



#### 场景 C：空池等待 (Empty Pool)

* **设定**：管理员设置了速率，但此时池子里一个质押的人都没有 ($TotalStaked = 0$)。
* **逻辑**：公式判定 $TotalStaked = 0$ 时，收益指数 $\Phi$ 不增长。
* **结果**：这段时间的奖励并没有分配给任何人，而是保留在合约中。随着时间推移，这部分奖励会顺延到有第一个人进入后继续释放，确保每一分钱都发给真实的贡献者。

---

## 6. 管理员权限模型与安全矩阵

### 6.1 权限层级与治理逻辑

* **Admin (多签钱包)**：修改费率、锁定期、TVL上限。受 **48小时时间锁 (TimeLock)** 约束。
* **Operator**：注入奖励、设置速率、业务暂停。
* **权限硬上限**：代码硬编码上限（费率 5%/20%，锁定 90天），即使多签被盗也无法瞬间卷款或无限期锁死。

---

### 6.2 紧急提款机制 (Emergency Withdraw) 专项说明

#### 1. 触发机制：谁来判断“极端情况”？

* **判断与触发者**：由 **Admin（超级管理员/多签钱包）** 手动触发。
* **触发方式**：管理员调用合约的 `setEmergencyMode(true)` 函数。
* **为何不采用链上自动触发？**：链上预言机或逻辑判定本身可能成为攻击向量。极端情况（如奖励计算公式发现严重 Bug 导致无法正常提现）通常需要人工介入确认。

#### 2. 授权方式：全局开放 vs 逐个授权

* **授权逻辑**：**管理员全局开放**。
* **操作流**：一旦管理员将合约状态切换为 `EmergencyMode`，**所有用户** 即可获得调用 `emergencyWithdraw()` 函数的权限。
* **原因**：在极端危机下，逐个授权用户会导致响应速度过慢，无法保护用户资产。管理员只需执行一次操作，即可打开全体逃生通道。

#### 3. 核心逻辑：跳过复杂计算

* **跳过内容**：紧急提款函数会**彻底跳过** `updateReward` 钩子、`rewardPerToken` 计算、以及所有关于  的发放逻辑。
* **只做一件事**：将用户在 `userStaked` 映射中记录的原始本金金额，通过 `transfer` 直接返还。

#### 4. 经济后果：奖励与手续费

* **奖励处理**：用户未领取的奖励将 **永久丢失 (Permanently Forfeited)**。
* *逻辑：* 紧急提款是为了在“数学逻辑已经崩坏”的情况下保本。由于计算奖励的逻辑可能已经失效（例如导致交易回滚的 Bug），系统无法再准确计算奖励，因此选择“舍利保本”。


* **手续费处理**：**0 手续费**。紧急提款会自动跳过：
* 标准提现费（1%）。
* 强制解押惩罚金（10%）。
* 所有锁定期检查。



#### 5. 与暂停状态（Pause）的关系

* **包含关系**：**暂停状态下可以进行紧急提款**。
* **优先级定义**：
* `Pause`（暂停）是 `Operator` 的权限，用于临时阻断攻击，此时所有提现都被锁死。
* `EmergencyMode`（紧急模式）是 `Admin` 的最高特权，它的优先级**高于** `Pause`。
* *代码实现：* `emergencyWithdraw` 函数**不带** `whenNotPaused` 修改器。即使在协议被暂停的情况下，只要紧急模式开启，用户依然可以取回本金。



---

### 权限与状态转换场景分析

| 操作行为 | 正常模式 | 暂停模式 (Pause) | 紧急模式 (Emergency) |
| --- | --- | --- | --- |
| **Stake / Compound** | 允许 | 禁止 | 禁止 |
| **Standard Withdraw** | 允许 (计算奖励/扣费) | 禁止 | 禁止 |
| **Emergency Withdraw** | 禁止 | 禁止 | **允许 (仅本金/0费率/丢奖励)** |

---

## 7. 收益率场景 (APR vs APY)

* **APR (单利)**：
$$APR = \frac{rewardRate \times 31,536,000}{totalStaked}$$
* **APY (复利)**：
$$APY = (1 + APR/n)^n - 1$$

> **场景分析（收益博弈）**：假设 APR 为 100%。小明每日手动复利，年底收益率为 171.4% (APY)，但他由于每日刷新计时，将面临永远无法 0 费率提取本金的代价。

---

## 8. 深度事件体系 (Events)

### 8.1 用户操作类

* `Staked(address indexed user, uint256 amount, uint256 totalUserStaked, uint256 unlockTime)`
* `Withdrawn(address indexed user, uint256 principal, uint256 feeAmount, uint256 rewardAmount)`
* `EarlyExited(address indexed user, uint256 principal, uint256 penaltyAmount, uint256 forfeitedReward)`
* `Compounded(address indexed user, uint256 rewardAmount, uint256 newTotalStaked, uint256 newUnlockTime)`

### 8.2 管理配置类

* `RewardAdded(uint256 rewardAmount, uint256 rate, uint256 periodFinish)`
* `FeeConfigUpdated(uint256 oldFeeBP, uint256 newFeeBP, string feeType)`
* `LockDurationUpdated(uint256 oldDuration, uint256 newDuration)`
* `EmergencyModeToggled(bool enabled, uint256 timestamp)`

---

## 9. 业务边界分析汇总

* **场景（粉尘防御）**：黑客尝试质押 0.0001 Token。由于 `amount < minStakeAmount`，交易回滚。
* **场景（管理员权限溢出）**：管理员试图设置 90% 手续费。合约由于硬上限校验，交易直接失败。
* **场景（奖励挤兑）**：若合约  余额为 0。`claim` 会触发回滚，保护用户账面数据，待项目方补足金额后即可领取。

---